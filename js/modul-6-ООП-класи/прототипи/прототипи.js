// Звідки беруться вбудовані методи масивів push, map, reduce та інші?
// Чому у функції є методи call і bind?
//     Досі ми просто приймали, що вони є і ними можна користуватися.Прийшов час знайти
//  відповіді на ці питання.
// Усе це можливо завдяки механізму прототипного успадкування, який дає змогу організувати
//  об'єкти в ланцюжки таким чином, щоб здійснювався автоматичний пошук властивості в іншому
//   об'єкті, якщо її не знайдено в поточному.

// Сполучною ланкою виступає спеціальна службова властивість[[Prototype]], яку ми не
// змінюємо явно, вона використовується для автоматичного зв'язку об'єктів.
// Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з
//  об'єктом obj. Розгляньмо приклад:
// const animal = {
//   legs: 4,
// };

// const dog = Object.create(animal);
// dog.name = "Mango";

// console.log(dog); // { name: "Mango", [[Prototype]]: animal }
// Об'єкт, на який вказує посилання у властивості [[Prototype]], називається прототипом.
//  У нашому прикладі об'єкт animal — це прототип для об'єкта dog.

// console.log(dog.name); // "Mango"
// console.log(dog.legs); // 4

// Звернення dog.name працює очевидним чином: повертає властивість name об'єкта dog.
//  Звертаючись до dog.legs, інтерпретатор шукає властивість legs в об'єкті dog, не
//  знаходить і продовжує пошук в об'єкті за посиланням з[[Prototype]], тобто в цьому
//  випадку в об'єкті animal — його прототипі.

// Отже, прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично
//  використовується під час їх пошуку.
