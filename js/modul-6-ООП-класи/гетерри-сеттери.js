// Геттери і сеттери — це спеціальний синтаксис оголошення методів для взаємодії з
// властивостями.Геттер і сеттер імітують звичайну публічну властивість класу, але
// дозволяють взаємодіяти з іншими властивостями зручнішим способом.

// class User {
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   // Геттер email
//   get email() {
//     return this.#email;
//   }

//   // Сеттер email
//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// У прикладі вище оголошені геттер і сеттер email.Щоб оголосити геттер і сеттер, потрібно
// поставити перед ім'ям властивості відповідні ключові слова — get і set. Всередині цих
// методів:
// повертаємо значення приватної властивості #email за допомогою геттера
// змінюємо її значення за допомогою сеттера

// Також вважається гарною практикою називати геттери і сеттери так само, як і властивість,
// з якою вони працюють.Це спрощує читання коду та його розуміння.Коли інші розробники бачать
// геттер чи сеттер, який називається так само, як і властивість, вони можуть легко
// здогадатися, що цей метод служить для доступу до конкретної властивості.Наприклад,
// геттер і сеттер для приватної властивості #email найлогічніше називати просто email,
// як у прикладі вище.
// Геттер і сеттер повинні називатися однаково.
// Краще називати геттери і сеттери так само, як і властивість, з якою вони працюють.
//  Геттер може існувати без сеттера, так само як і сеттер без геттера.
// Розгляньмо приклад: геттер виконується при спробі отримати значення властивості, а
// сеттер — при спробі її змінити.

// const mango = new User({
// 	name: "Mango",
// 	email: "mango@mail.com"
// });

// console.log(mango.email); // mango@mail.com

// mango.email = "mango@supermail.com";

// console.log(mango.email); // mango@supermail.com
// Звертаючись до mango.email, викликається геттер get email() {...} і виконується його код.
// При спробі запису mango.email = "mango@supermail.com" викликається сеттер
// set email(newEmail) {... }, і рядок "mango@supermail.com" буде значенням параметра
// newEmail.
// Перевага в тому, що це методи.Отже, під час запису або читання можна виконати додатковий
//  код з будь - якими перевірками, на відміну від виконання цієї ж операції безпосередньо
//  з властивістю.

// set email(newEmail) {
//   if(newEmail === "") {
//     console.log("Помилка! Пошта не може бути порожнім рядком!");
//     return;
//   }

//   this.#email = newEmail;
// }
// Геттери і сеттери доречно використовувати для простих операцій читання та зміни значення
// властивостей, особливо приватних, як їх публічний інтерфейс.Для роботи з властивістю, яка
//  зберігає масив або об'єкт, вони не підійдуть.

class Car {
  #brand;
  #model;
  #price;

  constructor({ brand, model, price }) {
    this.#brand = brand;
    this.#model = model;
    this.#price = price;
  }

  get brand() {
    return this.#brand;
  }

  set brand(newBrand) {
    this.#brand = newBrand;
  }

  get model() {
    return this.model;
  }

  set model(newModel) {
    this.model = newModel;
  }

  get price() {
    return this.price;
  }

  set price(newPrice) {
    this.price = newPrice;
  }
}
