// Контекст виконання функції
// Ключове слово thisВикористання імені самого об'єкта для доступу до його властивостей
// усередині методів є поганим підходом.Це те ж саме, що й кожен раз повторювати "Віктор"
// замість "він" у реченні.

// const user = {
//   username: "Victor",
//   showName() {
// 		// ❌ Віктор біжить швидко, тому що Віктор намагається зловити поїзд
//     console.log(user.username);
//   },
// };

// user.showName();
// Замість імені об'єкта, ми використовуємо зарезервоване ключове слово this.

// Під час виклику функції у this записується посилання на об'єкт, у контексті якого вона
// була викликана.Таким чином, у тілі функції ми можемо отримати доступ до властивостей і
//  методів цього об'єкта.

// const user = {
//   username: "Victor",
//   showName() {
// 		// ✅ Віктор біжить швидко, тому що він (this) намагається зловити поїзд.
//     console.log(this.username);
//   },
// };

// user.showName();

// Глобальний контекст
// У визначенні значення this є важливий нюанс.Значення this визначається не на момент
//  оголошення функції(за винятком стрілкових функцій), а на момент її виклику.Іншими
// словами, this визначається тим, як саме функцію викликали, а не де вона була оголошена.

// function foo() {
//   console.log(this);
// }

// foo(); // window

// У глобальному контексті, якщо функція виконується не в суворому режимі, this посилається
// на об'єкт window. Об'єкт window надає доступ до браузерних властивостей і функцій та є
// глобальним контекстом виконання для скриптів у браузері.

// У суворому режимі значення this у глобальному контексті завжди буде undefined.

// "use strict";

// function foo() {
//   console.log(this);
// }

// foo(); // undefined

// Контекст методу об'єкта
// Якщо функція була викликана як метод об'єкта, то контекст вказуватиме на сам об'єкт,
// якому належить цей метод.

// const user = {
//   username: "Poly",
//   showThis() {
//     console.log(this);
//   }
// };

// user.showThis(); // {username: "Poly", showThis: ƒ}

// Розглянемо складніший приклад.

// Спочатку створюємо функцію в глобальному контексті і викликаємо її.Зверни увагу на
//  використання суворого режиму.

// "use strict";

// function showThis() {
//   console.log("this in showThis: ", this);
// }

// // Викликаємо у глобальному контексті
// showThis(); // "this in showThis: undefined"

// Потім присвоюємо цю функцію властивості об'єкта і викликаємо її як метод цього об'єкта.

// "use strict";

// function showThis() {
//   console.log("this in showThis: ", this);
// }

// const user = {
//   username: "Poly",
// };

// user.showContext = showThis;

// // Викликаємо в контексті об'єкта
// user.showContext(); // this in showThis: {username: "Poly", showContext: ƒ}

// // Викликаємо в глобальному контексті
// showThis(); // "this in showThis: undefined"

// Створили об'єкт user з властивістю username
// Об'єкту user методу showContext присвоїли значення функції showThis. Зверни увагу, що це
// не виклик — немає()
// Тепер викликаємо метод showContext, у якому знаходиться посилання на функцію showThis,
//     тобто ми викликаємо функцію в контексті об'єкта. this вказуватиме на поточний об'єкт,
//         у якому здійснюється виклик

// Цей приклад ілюструє, що контекст виконання функції(this) визначається в момент її
// виклику, а не в момент оголошення.
