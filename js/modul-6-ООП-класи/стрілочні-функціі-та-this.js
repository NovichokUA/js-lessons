// Стрілочні функції
// Контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.
// Це означає, що this усередині стрілки посилається на контекст батьківської області
// видимості, в якій вона була оголошена, і ніколи не змінюється.
// const showThis = () => {
//   console.log("this in showThis: ", this);
// };
// showThis(); // this in showThis: window
// Навіть якщо присвоїти посилання на стрілочну функцію у властивість об'єкта і викликати
//  її в контексті цього об'єкта, this усе одно буде посилатися на об'єкт, який функція
//  запам'ятала в момент її оголошення.
// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// const user = {
//   username: "Mango",
// };

// user.showContext = showThis;
// user.showContext(); // this in showThis: window

// Стрілочні функції також ігнорують наявність суворого режиму.
// Якщо стрілка була оголошена в глобальному контексті, то this у ній буде містити
// посилання на window, незалежно від того, чи виконується скрипт у суворому режимі.
// "use strict";

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis(); // this in showThis: window
// Розгляньмо приклад, який добре ілюструє, як працює контекст для стрілочних функцій.
// const hotel = {
//   username: "Resort hotel",
//   showThis() {
//     const foo = () => {
//       console.log("this in foo: ", this);
//     };

//     foo();
//     console.log("this in showThis: ", this);
//   },
// };

// hotel.showThis();
//
// // this in foo: {username: 'Resort hotel', showThis: ƒ}
// // this in showThis: {username: 'Resort hotel',showThis: ƒ}

// Під час виклику методу hotel.showThis() стрілочна функція foo() викликається в
// глобальному контексті без об'єкта, але значення this усередині неї посилається на
// контекст методу showThis, тобто об'єкт hotel.Це тому, що вона була оголошена всередині
// методу showThis, і в момент її оголошення this запам'ятовує посилання на батьківський
// контекст.Інакше кажучи, стрілки запам'ятовують контекст під час оголошення з батьківської
//  області видимості.
// Можливо, це не часто використовується на практиці.Але такі кейси досить типові для
// співбесіди.
// На відміну від звичайних функцій, змінити значення this усередині стрілки після її
// оголошення неможливо.Це означає, що методи call, apply і bind не впливають на значення
// this у стрілках.

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis.call({ username: "Mango" }); // this in showThis: window
// showThis.apply({ username: "Mango" }); // this in showThis: window

// const boundShowThis = showThis.bind({ username: "Mango" });
// boundShowThis(); // this in showThis: window
//
// Обмежуючи стрілочні функції постійним контекстом, JavaScript - рушії можуть краще їх
// оптимізувати, на відміну від звичайних функцій, значення this яких може бути змінено.
// Що треба запам’ятати про this у стрілочних функціях?

//     1.Контекст ** this ** усередині стрілочної функції визначається місцем її оголошення, а не
// виклику.
// 2.Стрілочні функції ігнорують наявність суворого режиму.Тому в глобальному контексті у
// стрілці завжди this посилається на об'єкт window.
// 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення.
//  Методи call, apply і bind не впливають на значення this у стрілках.

const a = () => {
  console.log(this);
};
function b() {
  a();
}

b.call({ user: "Mango" }); //  window //І це правильна відповідь! Давай звіримо хід
// міркування: у прикладі оголошена стрілочна функція a, яка логує свій this.Функція a
// була створена в глобальному контексті, де this вказує на window.Хоча ми намагаємось
// змінити контекст функції b за допомогою call, стрілочна функція a ігнорує цей контекст.
// Тому при виклику a виведе window.
